📌 지적 사항: '단어장 목록'과 '단어 상세' 간의 불일치
다만, UX(사용자 경험) 일관성 측면에서 한 가지 치명적인 문제를 발견했으며, 이를 수정하기 위한 보완책을 제안합니다.

문제 상황: 계획안의 [문제 2]와 [데이터 우선순위 시스템]을 보면, 데이터가 저장되는 방식과 표시되는 방식이 분리되어 있습니다.

단어장에 저장되는 데이터:

"이 단어장만"으로 커스텀한 단어 (A)

또는 표준 DB에서 가져온 원본 단어 (B)

화면에 표시되는 데이터:

단어장 목록 (StudyModeView): 위 (1)번에 저장된 데이터 (A 또는 B)를 그대로 표시합니다.

단어 상세 (WordDetailScreen): "사용자 기본값" (C)이 있는지 확인하여, (C)가 존재하면 (A)나 (B) 대신 (C)를 표시합니다.

이것이 왜 문제인가요?

사용자는 단어장 목록(StudyModeView)에서 본 내용과 상세 화면(WordDetailScreen)에서 본 내용이 다를 수 있습니다.

예시 시나리오:

사용자가 "apple"의 '내 기본값'을 "사과 (스티브 잡스)"로 설정합니다.

이후, '수능 단어장'에 "apple"을 추가합니다.

'수능 단어장'에는 **표준 정의("사과")**가 저장됩니다.

사용자가 StudyModeView에서 '수능 단어장'을 엽니다.

목록에는 **"apple: 사과"**라고 표시됩니다. (저장된 원본이 표시됨)

사용자가 이 카드를 클릭해서 WordDetailScreen으로 들어갑니다.

상세 화면은 우선순위 로직에 따라 '사용자 기본값'을 가져와서 **"apple: 사과 (스티브 잡스)"**를 표시합니다.

결과: 사용자는 목록에서 '사과'를 보고 클릭했는데, 상세 화면에서 갑자기 '사과 (스티브 잡스)'를 보게 됩니다. 이는 매우 혼란스러운 경험입니다.

💡 해결 방안: '가상 단어장' 로직 적용
이 문제를 해결하려면, 단어장 목록(StudyModeView)을 불러올 때부터 최종 우선순위가 적용된 **"가상(Virtual) 단어장"**을 만들어서 보여줘야 합니다.

wordbookService.getWordbookWords 함수의 로직 수정 (핵심):

현재 이 함수는 단순히 AsyncStorage['wordbook_1']에 저장된 데이터를 반환합니다.

이것을 다음과 같이 변경해야 합니다.

AsyncStorage['wordbook_1']에 저장된 단어 목록을 불러옵니다. (예: 100개)

AsyncStorage['user_custom_defaults'] (사용자 기본값 맵)을 한 번에 불러옵니다.

100개의 단어를 순회(loop)하면서 새로운 배열을 만듭니다.

각 단어(word)에 대해:

If word.isCustomized === true (이 단어장에서 개별 커스텀됨)

→ 새 배열에 word를 그대로 추가합니다. (최우선)

Else If user_custom_defaults[word.word] (사용자 기본값이 존재함)

→ 새 배열에 사용자 기본값을 word 객체와 합쳐서 추가합니다.

Else (둘 다 해당 없음)

→ 새 배열에 word를 (원본) 그대로 추가합니다.

이 새롭게 조합된 배열을 StudyModeView로 반환합니다.

⚙️ 수정안에 따른 추가 변경 사항
1. 장점 (UX 일관성 확보)
이 방식을 사용하면 StudyModeView (목록)과 WordDetailScreen (상세)에 표시되는 내용이 항상 100% 일치하게 됩니다.

사용자는 목록에서 본 커스텀된 내용을 상세 화면에서도 그대로 볼 수 있습니다.

2. 성능 고려 (중요)
단점: 이 방식은 단어장을 열 때마다 모든 단어를 반복 확인하고 '사용자 기본값'과 비교해야 하므로, 단어장이 매우 커지면(1,000개 이상) 약간의 성능 저하가 발생할 수 있습니다.

해결: user_custom_defaults를 Map 객체로 미리 변환하여 메모리에 올려두고 O(1) 시간 복잡도로 조회하면, 성능 저하를 최소화할 수 있습니다. 현재 구조에서는 이것이 최선의 절충안입니다.

3. WordDetailScreen 로직 단순화
wordbookService.getWordDetail 함수가 매우 단순해집니다.

(기존 계획) getWordDetail이 복잡한 우선순위 로직을 수행

(수정 제안) getWordDetail은 getWordbookWords가 이미 만들어준 '가상 단어장' 배열에서 wordId로 단어를 찾아 반환하기만 하면 됩니다. (로직 중복 제거)

결론
이 한 가지 UX 문제를 제외하면, 계획의 나머지 부분(타입 정의, 모달 구현, 서비스 레이어 분리, 저장 옵션)은 모두 매우 훌륭하고 체계적입니다.